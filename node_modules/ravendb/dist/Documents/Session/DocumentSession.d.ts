import * as stream from "readable-stream";
import { ConcurrencyCheckMode, IDocumentSession, IDocumentSessionImpl, LoadOptions, SessionLoadInternalParameters, SessionLoadStartingWithOptions } from "./IDocumentSession";
import { DocumentConventions } from "../Conventions/DocumentConventions";
import { ClassConstructor, EntitiesCollectionObject, IRavenObject, ObjectTypeDescriptor } from "../../Types";
import { DocumentType } from "../DocumentAbstractions";
import { InMemoryDocumentSessionOperations } from "./InMemoryDocumentSessionOperations";
import { DocumentStore } from "../DocumentStore";
import { ILoaderWithInclude } from "./Loaders/ILoaderWithInclude";
import { IRawDocumentQuery } from "./IRawDocumentQuery";
import { AdvancedDocumentQueryOptions, DocumentQueryOptions } from "./QueryOptions";
import { IDocumentQuery } from "./IDocumentQuery";
import { IAttachmentsSessionOperations } from "./IAttachmentsSessionOperations";
import { IEagerSessionOperations } from "./Operations/Lazy/IEagerSessionOperations";
import { Lazy } from "../Lazy";
import { ILazyOperation } from "./Operations/Lazy/ILazyOperation";
import { ResponseTimeInformation } from "./ResponseTimeInformation";
import { ILazySessionOperations } from "./Operations/Lazy/ILazySessionOperations";
import { JavaScriptArray } from "./JavaScriptArray";
import { IRevisionsSessionOperations } from "./IRevisionsSessionOperations";
import { DocumentResultStream } from "./DocumentResultStream";
import { StreamQueryStatisticsCallback } from "./IAdvancedSessionOperations";
import { IClusterTransactionOperations } from "./IClusterTransactionOperations";
import { ClusterTransactionOperationsBase } from "./ClusterTransactionOperationsBase";
import { SessionOptions } from "./SessionOptions";
import { ISessionDocumentCounters } from "./ISessionDocumentCounters";
import { IGraphDocumentQuery } from "./IGraphDocumentQuery";
import { ISessionDocumentTimeSeries } from "./ISessionDocumentTimeSeries";
import { ISessionDocumentTypedTimeSeries } from "./ISessionDocumentTypedTimeSeries";
import { ISessionDocumentRollupTypedTimeSeries } from "./ISessionDocumentRollupTypedTimeSeries";
import { JavaScriptMap } from "./JavaScriptMap";
import { AbstractCommonApiForIndexes } from "../Indexes/AbstractCommonApiForIndexes";
import { ConditionalLoadResult } from "./ConditionalLoadResult";
export interface IStoredRawEntityInfo {
    originalValue: object;
    metadata: object;
    originalMetadata: object;
    id: string;
    changeVector?: string | null;
    expectedChangeVector?: string | null;
    concurrencyCheckMode: ConcurrencyCheckMode;
    documentType: DocumentType;
}
export declare class DocumentSession extends InMemoryDocumentSessionOperations implements IDocumentSession, IDocumentSessionImpl {
    constructor(documentStore: DocumentStore, id: string, options: SessionOptions);
    get advanced(): this;
    get session(): InMemoryDocumentSessionOperations;
    protected _generateId(entity: object): Promise<string>;
    numberOfRequestsInSession: number;
    load<TEntity extends object = IRavenObject>(id: string): Promise<TEntity | null>;
    load<TEntity extends object = IRavenObject>(id: string, options?: LoadOptions<TEntity>): Promise<TEntity | null>;
    load<TEntity extends object = IRavenObject>(id: string, documentType?: DocumentType<TEntity>): Promise<TEntity | null>;
    load<TEntity extends object = IRavenObject>(ids: string[]): Promise<EntitiesCollectionObject<TEntity>>;
    load<TEntity extends object = IRavenObject>(ids: string[], options?: LoadOptions<TEntity>): Promise<EntitiesCollectionObject<TEntity>>;
    load<TEntity extends object = IRavenObject>(ids: string[], documentType?: DocumentType<TEntity>): Promise<EntitiesCollectionObject<TEntity>>;
    private _prepareLoadInternalOpts;
    private _loadInternal;
    saveChanges(): Promise<void>;
    refresh<TEntity extends object>(entity: TEntity): Promise<void>;
    exists(id: string): Promise<boolean>;
    loadStartingWith<TEntity extends object>(idPrefix: string): Promise<TEntity[]>;
    loadStartingWith<TEntity extends object>(idPrefix: string, opts: SessionLoadStartingWithOptions<TEntity>): Promise<TEntity[]>;
    loadStartingWithIntoStream<TEntity extends object>(idPrefix: string, writable: stream.Writable): Promise<void>;
    loadStartingWithIntoStream<TEntity extends object>(idPrefix: string, writable: stream.Writable, opts: SessionLoadStartingWithOptions<TEntity>): Promise<void>;
    loadIntoStream(ids: string[], writable: stream.Writable): Promise<void>;
    private _loadStartingWithInternal;
    loadInternal<TResult extends object>(ids: string[], opts: SessionLoadInternalParameters<TResult>): Promise<EntitiesCollectionObject<TResult>>;
    include(path: string): ILoaderWithInclude;
    increment<T extends object, UValue>(id: string, path: string, valueToAdd: UValue): void;
    increment<T extends object, UValue>(entity: T, path: string, valueToAdd: UValue): void;
    addOrIncrement<T extends object, UValue>(id: string, entity: T, pathToObject: string, valToAdd: UValue): void;
    addOrPatchArray<T extends object, UValue>(id: string, entity: T, pathToArray: string, arrayAdder: (array: JavaScriptArray<UValue>) => void): void;
    addOrPatch<T extends object, UValue>(id: string, entity: T, pathToObject: string, value: UValue): void;
    private _valsCount;
    private _customCount;
    patch<TEntity extends object, UValue>(id: string, path: string, value: UValue): void;
    patch<TEntity extends object, UValue>(entity: TEntity, path: string, value: UValue): void;
    patchArray<TEntity extends object, UValue>(id: string, pathToArray: string, arrayAdder: (array: JavaScriptArray<UValue>) => void): void;
    patchArray<TEntity extends object, UValue>(entity: TEntity, pathToArray: string, arrayAdder: (array: JavaScriptArray<UValue>) => void): void;
    patchObject<TEntity extends object, TKey, TValue>(entity: TEntity, pathToObject: string, mapAdder: (map: JavaScriptMap<TKey, TValue>) => void): void;
    patchObject<TEntity extends object, TKey, TValue>(id: string, pathToObject: string, mapAdder: (map: JavaScriptMap<TKey, TValue>) => void): void;
    private _tryMergePatches;
    rawQuery<TEntity extends object>(query: string, documentType?: DocumentType<TEntity>): IRawDocumentQuery<TEntity>;
    query<TEntity extends object>(documentType: DocumentType<TEntity>): IDocumentQuery<TEntity>;
    query<TEntity extends object>(documentType: DocumentType<TEntity>, index: new () => AbstractCommonApiForIndexes): IDocumentQuery<TEntity>;
    query<TEntity extends object>(opts: DocumentQueryOptions<TEntity>): IDocumentQuery<TEntity>;
    documentQuery<T extends object>(opts: AdvancedDocumentQueryOptions<T>): IDocumentQuery<T>;
    documentQuery<T extends object>(documentType: DocumentType<T>): IDocumentQuery<T>;
    protected _processQueryParameters<T extends object>(opts: AdvancedDocumentQueryOptions<T>, conventions: DocumentConventions): {
        indexName: string;
        collection: string;
    };
    private _attachments;
    get attachments(): IAttachmentsSessionOperations;
    private _revisions;
    get revisions(): IRevisionsSessionOperations;
    private _clusterTransaction;
    get clusterTransaction(): IClusterTransactionOperations;
    protected _hasClusterSession(): boolean;
    protected _clearClusterSession(): void;
    get clusterSession(): ClusterTransactionOperationsBase;
    get lazily(): ILazySessionOperations;
    get eagerly(): IEagerSessionOperations;
    executeAllPendingLazyOperations(): Promise<ResponseTimeInformation>;
    private _executeLazyOperationsSingleStep;
    addLazyOperation<TLazyResult>(operation: ILazyOperation): Lazy<TLazyResult>;
    addLazyCountOperation(operation: ILazyOperation): Lazy<number>;
    lazyLoadInternal<TResult extends object>(ids: string[], includes: string[], clazz: ObjectTypeDescriptor<TResult>): Lazy<EntitiesCollectionObject<TResult>>;
    stream<T extends object>(query: IDocumentQuery<T>): Promise<DocumentResultStream<T>>;
    stream<T extends object>(query: IDocumentQuery<T>, streamQueryStats: StreamQueryStatisticsCallback): Promise<DocumentResultStream<T>>;
    stream<T extends object>(query: IRawDocumentQuery<T>): Promise<DocumentResultStream<T>>;
    stream<T extends object>(query: IRawDocumentQuery<T>, streamQueryStats: StreamQueryStatisticsCallback): Promise<DocumentResultStream<T>>;
    stream<T extends object>(idPrefix: string): Promise<DocumentResultStream<T>>;
    stream<T extends object>(idPrefix: string, opts: SessionLoadStartingWithOptions<T>): Promise<DocumentResultStream<T>>;
    private _streamStartingWith;
    private _streamQueryResults;
    private _getStreamResultTransform;
    streamInto<T extends object>(query: IDocumentQuery<T>, writable: stream.Writable): Promise<void>;
    streamInto<T extends object>(query: IRawDocumentQuery<T>, writable: stream.Writable): Promise<void>;
    countersFor(documentId: string): ISessionDocumentCounters;
    countersFor(entity: object): ISessionDocumentCounters;
    graphQuery<TEntity extends object>(query: string, documentType?: DocumentType<TEntity>): IGraphDocumentQuery<TEntity>;
    timeSeriesFor(documentId: string, name: string): ISessionDocumentTimeSeries;
    timeSeriesFor(entity: any, name: string): ISessionDocumentTimeSeries;
    timeSeriesFor<T extends object>(documentId: string, clazz: ClassConstructor<T>): ISessionDocumentTypedTimeSeries<T>;
    timeSeriesFor<T extends object>(documentId: string, name: string, clazz: ClassConstructor<T>): ISessionDocumentTypedTimeSeries<T>;
    timeSeriesFor<T extends object>(entity: object, clazz: ClassConstructor<T>): ISessionDocumentTypedTimeSeries<T>;
    timeSeriesFor<T extends object>(entity: object, name: string, clazz: ClassConstructor<T>): ISessionDocumentTypedTimeSeries<T>;
    timeSeriesRollupFor<T extends object>(entity: object, policy: string, clazz: ClassConstructor<T>): ISessionDocumentRollupTypedTimeSeries<T>;
    timeSeriesRollupFor<T extends object>(entity: object, policy: string, raw: string, clazz: ClassConstructor<T>): ISessionDocumentRollupTypedTimeSeries<T>;
    timeSeriesRollupFor<T extends object>(documentId: string, policy: string, clazz: ClassConstructor<T>): ISessionDocumentRollupTypedTimeSeries<T>;
    timeSeriesRollupFor<T extends object>(documentId: string, policy: string, raw: string, clazz: ClassConstructor<T>): ISessionDocumentRollupTypedTimeSeries<T>;
    conditionalLoad<T extends object>(id: string, changeVector: string, clazz: ClassConstructor<T>): Promise<ConditionalLoadResult<T>>;
}
