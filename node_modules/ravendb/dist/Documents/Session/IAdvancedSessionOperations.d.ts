import { StreamQueryStatistics } from "../Session/StreamQueryStatistics";
import { RequestExecutor } from "../../Http/RequestExecutor";
import { ServerNode } from "../../Http/ServerNode";
import { ICommandData } from "../Commands/CommandData";
import { IDocumentStore } from "../IDocumentStore";
import { DocumentsChanges } from "./DocumentsChanges";
import { EntityToJson } from "./EntityToJson";
import { IMetadataDictionary } from "./IMetadataDictionary";
import { SessionEventsEmitter } from "./SessionEvents";
import { TransactionMode } from "./TransactionMode";
import { IEagerSessionOperations } from "./Operations/Lazy/IEagerSessionOperations";
import { ILazySessionOperations } from "./Operations/Lazy/ILazySessionOperations";
import { IAttachmentsSessionOperations } from "./IAttachmentsSessionOperations";
import { IRevisionsSessionOperations } from "./IRevisionsSessionOperations";
import { IClusterTransactionOperations } from "./IClusterTransactionOperations";
import { DocumentType } from "../DocumentAbstractions";
import { IRawDocumentQuery } from "./IRawDocumentQuery";
import { SessionInfo, SessionLoadStartingWithOptions } from "./IDocumentSession";
import { IDocumentQuery } from "./IDocumentQuery";
import { JavaScriptArray } from "./JavaScriptArray";
import { DocumentResultStream } from "./DocumentResultStream";
import * as stream from "readable-stream";
import { IDocumentQueryBuilder } from "./IDocumentQueryBuilder";
import { IGraphDocumentQuery } from "./IGraphDocumentQuery";
import { JavaScriptMap } from "./JavaScriptMap";
import { ConditionalLoadResult } from "./ConditionalLoadResult";
export type StreamQueryStatisticsCallback = (stats: StreamQueryStatistics) => void;
export interface IAdvancedSessionOperations extends IAdvancedDocumentSessionOperations, IDocumentQueryBuilder {
    eagerly: IEagerSessionOperations;
    lazily: ILazySessionOperations;
    attachments: IAttachmentsSessionOperations;
    revisions: IRevisionsSessionOperations;
    clusterTransaction: IClusterTransactionOperations;
    refresh<TEntity extends object>(entity: TEntity): Promise<void>;
    rawQuery<TResult extends object>(query: string, documentType?: DocumentType<TResult>): IRawDocumentQuery<TResult>;
    graphQuery<TResult extends object>(query: string, documentType?: DocumentType<TResult>): IGraphDocumentQuery<TResult>;
    exists(id: string): Promise<boolean>;
    loadStartingWith<T extends object>(idPrefix: string, opts: SessionLoadStartingWithOptions<T>): Promise<T[]>;
    loadStartingWith<T extends object>(idPrefix: string): Promise<T[]>;
    increment<TEntity extends object, UValue>(id: string, path: string, valueToAdd: UValue): void;
    increment<TEntity extends object, UValue>(entity: TEntity, path: string, valueToAdd: UValue): void;
    patch<TEntity extends object, UValue>(id: string, path: string, value: UValue): void;
    patch<TEntity extends object, UValue>(entity: TEntity, path: string, value: UValue): void;
    patchArray<TEntity extends object, UValue>(id: string, pathToArray: string, arrayAdder: (array: JavaScriptArray<UValue>) => void): void;
    patchArray<TEntity extends object, UValue>(entity: TEntity, pathToArray: string, arrayAdder: (array: JavaScriptArray<UValue>) => void): void;
    patchObject<TEntity extends object, TKey, TValue>(entity: TEntity, pathToObject: string, mapAdder: (map: JavaScriptMap<TKey, TValue>) => void): void;
    patchObject<TEntity extends object, TKey, TValue>(id: string, pathToObject: string, mapAdder: (map: JavaScriptMap<TKey, TValue>) => void): void;
    addOrPatch<TEntity extends object, UValue>(id: string, entity: TEntity, pathToObject: string, value: UValue): void;
    addOrPatchArray<TEntity extends object, UValue>(id: string, entity: TEntity, pathToObject: string, arrayAdder: (array: JavaScriptArray<UValue>) => void): void;
    addOrIncrement<TEntity extends object, UValue>(id: string, entity: TEntity, pathToObject: string, valToAdd: UValue): void;
    streamInto<T extends object>(query: IDocumentQuery<T>, writable: stream.Writable): Promise<void>;
    streamInto<T extends object>(query: IRawDocumentQuery<T>, writable: stream.Writable): Promise<void>;
    loadIntoStream(ids: string[], writable: stream.Writable): Promise<void>;
    loadStartingWithIntoStream<TEntity extends object>(idPrefix: string, writable: stream.Writable): Promise<void>;
    loadStartingWithIntoStream<TEntity extends object>(idPrefix: string, writable: stream.Writable, opts: SessionLoadStartingWithOptions<TEntity>): Promise<void>;
    stream<T extends object>(query: IDocumentQuery<T>): Promise<DocumentResultStream<T>>;
    stream<T extends object>(query: IDocumentQuery<T>, streamQueryStats: StreamQueryStatisticsCallback): Promise<DocumentResultStream<T>>;
    stream<T extends object>(query: IRawDocumentQuery<T>): Promise<DocumentResultStream<T>>;
    stream<T extends object>(query: IRawDocumentQuery<T>, streamQueryStats: StreamQueryStatisticsCallback): Promise<DocumentResultStream<T>>;
    stream<T extends object>(idPrefix: string): Promise<DocumentResultStream<T>>;
    stream<T extends object>(idPrefix: string, opts: SessionLoadStartingWithOptions<T>): Promise<DocumentResultStream<T>>;
    conditionalLoad<T extends object>(id: string, changeVector: string, clazz: DocumentType<T>): Promise<ConditionalLoadResult<T>>;
}
export interface ReplicationBatchOptions {
    timeout?: number;
    throwOnTimeout?: boolean;
    replicas?: number;
    majority?: boolean;
}
export interface IndexBatchOptions {
    timeout?: number;
    throwOnTimeout?: boolean;
    indexes?: string[];
}
export interface IAdvancedDocumentSessionOperations extends SessionEventsEmitter {
    documentStore: IDocumentStore;
    externalState: Map<string, object>;
    getCurrentSessionNode(): Promise<ServerNode>;
    requestExecutor: RequestExecutor;
    sessionInfo: SessionInfo;
    hasChanges(): boolean;
    maxNumberOfRequestsPerSession: number;
    numberOfRequests: number;
    storeIdentifier: string;
    useOptimisticConcurrency: boolean;
    clear(): void;
    defer(...commands: ICommandData[]): void;
    evict<TEntity extends object>(entity: TEntity): void;
    getDocumentId(entity: object): string;
    getMetadataFor<T extends object>(instance: T): IMetadataDictionary;
    getChangeVectorFor<T extends object>(instance: T): string;
    getCountersFor<T extends object>(instance: T): string[];
    getTimeSeriesFor<T extends object>(instance: T): string[];
    getLastModifiedFor<T extends object>(instance: T): Date;
    hasChanged(entity: object): boolean;
    isLoaded(id: string): boolean;
    ignoreChangesFor(entity: object): void;
    whatChanged(): {
        [id: string]: DocumentsChanges[];
    };
    waitForReplicationAfterSaveChanges(): any;
    waitForReplicationAfterSaveChanges(opts: ReplicationBatchOptions): any;
    waitForIndexesAfterSaveChanges(): any;
    waitForIndexesAfterSaveChanges(opts: IndexBatchOptions): any;
    entityToJson: EntityToJson;
    transactionMode: TransactionMode;
}
