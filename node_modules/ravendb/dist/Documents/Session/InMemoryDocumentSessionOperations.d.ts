/// <reference types="node" />
import { EntityToJson } from "./EntityToJson";
import { IDisposable } from "../../Types/Contracts";
import { SessionInfo, ConcurrencyCheckMode, StoreOptions } from "./IDocumentSession";
import { IMetadataDictionary } from "./IMetadataDictionary";
import { ObjectTypeDescriptor, ServerResponse } from "../../Types";
import { SessionEventsEmitter } from "./SessionEvents";
import { RequestExecutor } from "../../Http/RequestExecutor";
import { IDocumentStore } from "../IDocumentStore";
import { ServerNode } from "../../Http/ServerNode";
import { DocumentsById } from "./DocumentsById";
import { DocumentInfo } from "./DocumentInfo";
import { DocumentStoreBase } from "../DocumentStoreBase";
import { ICommandData, SaveChangesData } from "../Commands/CommandData";
import { GenerateEntityIdOnTheClient } from "../Identity/GenerateEntityIdOnTheClient";
import { DocumentType } from "../DocumentAbstractions";
import { DocumentsChanges } from "./DocumentsChanges";
import { EventEmitter } from "events";
import { IRavenObject } from "../../Types/IRavenObject";
import { GetDocumentsResult } from "../Commands/GetDocumentsCommand";
import { DocumentConventions } from "../Conventions/DocumentConventions";
import { RavenCommand } from "../../Http/RavenCommand";
import { JsonSerializer } from "../../Mapping/Json/Serializer";
import { OperationExecutor } from "../Operations/OperationExecutor";
import { IndexBatchOptions, ReplicationBatchOptions } from "./IAdvancedSessionOperations";
import { ILazyOperation } from "./Operations/Lazy/ILazyOperation";
import { TransactionMode } from "./TransactionMode";
import { CounterTracking } from "./CounterInternalTypes";
import { DocumentStore } from "../DocumentStore";
import { SessionOptions } from "./SessionOptions";
import { ClusterTransactionOperationsBase } from "./ClusterTransactionOperationsBase";
import { BatchCommandResult } from "./Operations/BatchCommandResult";
import { Reference } from "../../Utility/Reference";
import { ForceRevisionStrategy } from "./ForceRevisionStrategy";
import { TimeSeriesRangeResult } from "../Operations/TimeSeries/TimeSeriesRangeResult";
import { TimeSeriesEntry } from "./TimeSeries/TimeSeriesEntry";
export declare abstract class InMemoryDocumentSessionOperations extends EventEmitter implements IDisposable, SessionEventsEmitter {
    protected _requestExecutor: RequestExecutor;
    private _operationExecutor;
    protected _pendingLazyOperations: ILazyOperation[];
    protected static _instancesCounter: number;
    private _hash;
    private _disposed;
    protected _jsonSerializer: JsonSerializer;
    private readonly _id;
    get id(): string;
    protected _knownMissingIds: Set<string>;
    private _externalState;
    disableAtomicDocumentWritesInClusterWideTransaction: boolean;
    private _transactionMode;
    get externalState(): Map<string, object>;
    getCurrentSessionNode(): Promise<ServerNode>;
    documentsById: DocumentsById;
    get countersByDocId(): Map<string, CounterTracking>;
    private _countersByDocId;
    private _timeSeriesByDocId;
    get timeSeriesByDocId(): Map<string, Map<string, TimeSeriesRangeResult[]>>;
    readonly noTracking: boolean;
    idsForCreatingForcedRevisions: Map<string, ForceRevisionStrategy>;
    includedDocumentsById: Map<string, DocumentInfo>;
    includeRevisionsByChangeVector: Map<string, DocumentInfo>;
    includeRevisionsIdByDateTimeBefore: Map<string, Map<number, DocumentInfo>>;
    documentsByEntity: DocumentsByEntityHolder;
    deletedEntities: DeletedEntitiesHolder;
    protected _documentStore: DocumentStoreBase;
    private readonly _databaseName;
    private _saveChangesOptions;
    get databaseName(): string;
    get documentStore(): IDocumentStore;
    get requestExecutor(): RequestExecutor;
    get sessionInfo(): SessionInfo;
    get operations(): OperationExecutor;
    private _numberOfRequests;
    get numberOfRequests(): number;
    getNumberOfEntitiesInUnitOfWork(): number;
    get storeIdentifier(): string;
    get conventions(): DocumentConventions;
    maxNumberOfRequestsPerSession: number;
    useOptimisticConcurrency: boolean;
    protected _deferredCommands: ICommandData[];
    deferredCommandsMap: Map<string, ICommandData>;
    get deferredCommands(): ICommandData[];
    get deferredCommandsCount(): number;
    private readonly _generateEntityIdOnTheClient;
    get generateEntityIdOnTheClient(): GenerateEntityIdOnTheClient;
    private readonly _entityToJson;
    get entityToJson(): EntityToJson;
    protected _sessionInfo: SessionInfo;
    protected constructor(documentStore: DocumentStore, id: string, options: SessionOptions);
    protected abstract _generateId(entity: object): Promise<string>;
    getMetadataFor<T extends object>(instance: T): IMetadataDictionary;
    getCountersFor<T extends object>(instance: T): string[];
    getTimeSeriesFor<T extends object>(instance: T): string[];
    private _makeMetadataInstance;
    private _getDocumentInfo;
    protected _assertNoNonUniqueInstance(entity: object, id: string): void;
    getChangeVectorFor<T extends object>(instance: T): string;
    getLastModifiedFor<T extends object>(instance: T): Date;
    isLoaded(id: string): boolean;
    isLoadedOrDeleted(id: string): boolean;
    isDeleted(id: string): boolean;
    getDocumentId(instance: object): string;
    incrementRequestCount(): void;
    checkIfAllChangeVectorsAreAlreadyIncluded(changeVectors: string[]): boolean;
    checkIfRevisionByDateTimeBeforeAlreadyIncluded(id: string, dateTime: Date): boolean;
    checkIfIdAlreadyIncluded(ids: string[], includes: string[]): boolean;
    trackEntity<T extends object>(entityType: ObjectTypeDescriptor<T>, documentFound: DocumentInfo): T;
    trackEntity<T extends object>(entityType: ObjectTypeDescriptor<T>, id: string, document: object, metadata: object, noTracking: boolean): object;
    registerExternalLoadedIntoTheSession(info: DocumentInfo): void;
    private _deserializeFromTransformer;
    registerIncludes(includes: object): void;
    registerRevisionIncludes(revisionIncludes: any[]): void;
    registerMissingIncludes(results: object[], includes: object, includePaths: string[]): void;
    registerMissing(idOrIds: string | string[]): void;
    unregisterMissing(id: string): void;
    registerCounters(resultCounters: object, countersToInclude: {
        [key: string]: string[];
    }): void;
    registerCounters(resultCounters: object, ids: string[], countersToInclude: string[], gotAll: boolean): void;
    private _registerCountersWithIdsList;
    private _registerCountersWithCountersToIncludeObj;
    private _registerCountersInternal;
    private _registerCountersForDocument;
    private _setGotAllInCacheIfNeeded;
    private _setGotAllCountersForDocument;
    private _registerMissingCounters;
    registerTimeSeries(resultTimeSeries: Record<string, Record<string, ServerResponse<TimeSeriesRangeResult>[]>>): void;
    private static _addToCache;
    static addToCache(timeseries: string, from: Date, to: Date, fromRangeIndex: number, toRangeIndex: number, ranges: TimeSeriesRangeResult[], cache: Map<string, TimeSeriesRangeResult[]>, values: TimeSeriesEntry[]): void;
    private static _parseTimeSeriesRangeResult;
    private static _mergeRanges;
    private static _updateExistingRange;
    private _registerMissingCountersWithCountersToIncludeObj;
    private _registerMissingCountersWithIdsList;
    store<TEntity extends object>(entity: TEntity): Promise<void>;
    store<TEntity extends object>(entity: TEntity, id?: string): Promise<void>;
    store<TEntity extends object>(entity: TEntity, id?: string, documentType?: DocumentType<TEntity>): Promise<void>;
    store<TEntity extends object>(entity: TEntity, id?: string, options?: StoreOptions<TEntity>): Promise<void>;
    protected _generateDocumentKeysOnStore: boolean;
    private _storeInternal;
    protected _storeEntityInUnitOfWork(id: string, entity: object, changeVector: string, metadata: object, forceConcurrencyCheck: ConcurrencyCheckMode, documentType: DocumentType): void;
    protected _rememberEntityForDocumentIdGeneration(entity: object): void;
    prepareForSaveChanges(): SaveChangesData;
    validateClusterTransaction(result: SaveChangesData): void;
    protected _updateSessionAfterSaveChanges(result: BatchCommandResult): void;
    onBeforeConversionToDocumentInvoke(id: string, entity: object): void;
    onAfterConversionToDocumentInvoke(id: string, entity: object, document: Reference<object>): void;
    onBeforeConversionToEntityInvoke(id: string, type: DocumentType, document: Reference<object>): void;
    onAfterConversionToEntityInvoke(id: string, document: object, entity: object): void;
    private _prepareCompareExchangeEntities;
    protected abstract _hasClusterSession(): boolean;
    protected abstract _clearClusterSession(): void;
    abstract clusterSession: ClusterTransactionOperationsBase;
    private _newSaveChangesData;
    private _prepareForCreatingRevisionsFromIds;
    private _prepareForEntitiesDeletion;
    private _prepareForEntitiesPuts;
    protected _entityChanged(newObj: object, documentInfo: DocumentInfo, changes: {
        [id: string]: DocumentsChanges[];
    }): boolean;
    private static _throwInvalidModifiedDocumentWithDeferredCommand;
    private static _throwInvalidDeletedDocumentWithDeferredCommand;
    private static _updateMetadataModifications;
    delete(id: string): Promise<void>;
    delete(id: string, expectedChangeVector: string): Promise<void>;
    delete<TEntity extends IRavenObject>(entity: TEntity): Promise<void>;
    private _deleteByEntity;
    private _deleteById;
    defer(...commands: ICommandData[]): void;
    private _deferInternal;
    private _addCommand;
    protected _refreshInternal<T extends object>(entity: T, cmd: RavenCommand<GetDocumentsResult>, documentInfo: DocumentInfo): void;
    hasChanges(): boolean;
    evict<T extends object>(entity: T): void;
    clear(): void;
    hasChanged(entity: object): boolean;
    waitForReplicationAfterSaveChanges(): any;
    waitForReplicationAfterSaveChanges(opts: ReplicationBatchOptions): any;
    waitForIndexesAfterSaveChanges(): any;
    waitForIndexesAfterSaveChanges(opts: IndexBatchOptions): any;
    ignoreChangesFor(entity: object): void;
    whatChanged(): {
        [id: string]: DocumentsChanges[];
    };
    private _getAllEntitiesChanges;
    dispose(isDisposing?: boolean): void;
    get transactionMode(): TransactionMode;
    set transactionMode(value: TransactionMode);
    private static _throwNoDatabase;
}
export declare class DocumentsByEntityHolder implements Iterable<DocumentsByEntityEnumeratorResult> {
    private readonly _documentsByEntity;
    private _onBeforeStoreDocumentsByEntity;
    private _prepareEntitiesPuts;
    get size(): number;
    remove(entity: object): void;
    evict(entity: object): void;
    put(entity: object, documentInfo: DocumentInfo): void;
    private _createOnBeforeStoreDocumentsByEntityIfNeeded;
    clear(): void;
    get(entity: object): DocumentInfo;
    [Symbol.iterator](): Iterator<DocumentsByEntityEnumeratorResult>;
    prepareEntitiesPuts(): IDisposable;
}
export interface DocumentsByEntityEnumeratorResult {
    key: object;
    value: DocumentInfo;
    executeOnBeforeStore: boolean;
}
export declare class DeletedEntitiesHolder implements Iterable<DeletedEntitiesEnumeratorResult> {
    private readonly _deletedEntities;
    private _onBeforeDeletedEntities;
    private _prepareEntitiesDeletes;
    isEmpty(): boolean;
    get size(): number;
    add(entity: object): void;
    remove(entity: object): void;
    evict(entity: object): void;
    contains(entity: object): boolean;
    clear(): void;
    [Symbol.iterator](): Iterator<DeletedEntitiesEnumeratorResult>;
    prepareEntitiesDeletes(): IDisposable;
}
export interface DeletedEntitiesEnumeratorResult {
    entity: object;
    executeOnBeforeDelete: boolean;
}
